//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class ApiError: APIModel {

    public enum ApiErrorType: String, Codable {
        case authorizer = "AUTHORIZER"
        case jano = "JANO"

        public static let cases: [ApiErrorType] = [
          .authorizer,
          .jano,
        ]
    }

    public enum Status: String, Codable {
        case _100Continue = "100 CONTINUE"
        case _101SwitchingProtocols = "101 SWITCHING_PROTOCOLS"
        case _102Processing = "102 PROCESSING"
        case _103Checkpoint = "103 CHECKPOINT"
        case _200Ok = "200 OK"
        case _201Created = "201 CREATED"
        case _202Accepted = "202 ACCEPTED"
        case _203NonAuthoritativeInformation = "203 NON_AUTHORITATIVE_INFORMATION"
        case _204NoContent = "204 NO_CONTENT"
        case _205ResetContent = "205 RESET_CONTENT"
        case _206PartialContent = "206 PARTIAL_CONTENT"
        case _207MultiStatus = "207 MULTI_STATUS"
        case _208AlreadyReported = "208 ALREADY_REPORTED"
        case _226ImUsed = "226 IM_USED"
        case _300MultipleChoices = "300 MULTIPLE_CHOICES"
        case _301MovedPermanently = "301 MOVED_PERMANENTLY"
        case _302Found = "302 FOUND"
        case _302MovedTemporarily = "302 MOVED_TEMPORARILY"
        case _303SeeOther = "303 SEE_OTHER"
        case _304NotModified = "304 NOT_MODIFIED"
        case _305UseProxy = "305 USE_PROXY"
        case _307TemporaryRedirect = "307 TEMPORARY_REDIRECT"
        case _308PermanentRedirect = "308 PERMANENT_REDIRECT"
        case _400BadRequest = "400 BAD_REQUEST"
        case _401Unauthorized = "401 UNAUTHORIZED"
        case _402PaymentRequired = "402 PAYMENT_REQUIRED"
        case _403Forbidden = "403 FORBIDDEN"
        case _404NotFound = "404 NOT_FOUND"
        case _405MethodNotAllowed = "405 METHOD_NOT_ALLOWED"
        case _406NotAcceptable = "406 NOT_ACCEPTABLE"
        case _407ProxyAuthenticationRequired = "407 PROXY_AUTHENTICATION_REQUIRED"
        case _408RequestTimeout = "408 REQUEST_TIMEOUT"
        case _409Conflict = "409 CONFLICT"
        case _410Gone = "410 GONE"
        case _411LengthRequired = "411 LENGTH_REQUIRED"
        case _412PreconditionFailed = "412 PRECONDITION_FAILED"
        case _413PayloadTooLarge = "413 PAYLOAD_TOO_LARGE"
        case _413RequestEntityTooLarge = "413 REQUEST_ENTITY_TOO_LARGE"
        case _414UriTooLong = "414 URI_TOO_LONG"
        case _414RequestUriTooLong = "414 REQUEST_URI_TOO_LONG"
        case _415UnsupportedMediaType = "415 UNSUPPORTED_MEDIA_TYPE"
        case _416RequestedRangeNotSatisfiable = "416 REQUESTED_RANGE_NOT_SATISFIABLE"
        case _417ExpectationFailed = "EXPECTATION_FAILED"
        case _418IAmaTeapot = "418 I_AM_A_TEAPOT"
        case _419InsufficientSpaceOnResource = "419 INSUFFICIENT_SPACE_ON_RESOURCE"
        case _420MethodFailure = "420 METHOD_FAILURE"
        case _421DestinationLocked = "421 DESTINATION_LOCKED"
        case _422UnprocessableEntity = "422 UNPROCESSABLE_ENTITY"
        case _423Locked = "423 LOCKED"
        case _424FailedDependency = "424 FAILED_DEPENDENCY"
        case _426UpgradeRequired = "426 UPGRADE_REQUIRED"
        case _428PreconditionRequired = "428 PRECONDITION_REQUIRED"
        case _429TooManyRequests = "429 TOO_MANY_REQUESTS"
        case _431RequestHeaderFieldsTooLarge = "431 REQUEST_HEADER_FIELDS_TOO_LARGE"
        case _451UnavailableForLegalReasons = "451 UNAVAILABLE_FOR_LEGAL_REASONS"
        case _500InternalServerError = "500 INTERNAL_SERVER_ERROR"
        case _501NotImplemented = "501 NOT_IMPLEMENTED"
        case _502BadGateway = "502 BAD_GATEWAY"
        case _503ServiceUnavailable = "503 SERVICE_UNAVAILABLE"
        case _504GatewayTimeout = "504 GATEWAY_TIMEOUT"
        case _505HttpVersionNotSupported = "505 HTTP_VERSION_NOT_SUPPORTED"
        case _506VariantAlsoNegotiates = "506 VARIANT_ALSO_NEGOTIATES"
        case _507InsufficientStorage = "507 INSUFFICIENT_STORAGE"
        case _508LoopDetected = "508 LOOP_DETECTED"
        case _509BandwidthLimitExceeded = "509 BANDWIDTH_LIMIT_EXCEEDED"
        case _510NotExtended = "510 NOT_EXTENDED"
        case _511NetworkAuthenticationRequired = "511 NETWORK_AUTHENTICATION_REQUIRED"

        public static let cases: [Status] = [
          ._100Continue,
          ._101SwitchingProtocols,
          ._102Processing,
          ._103Checkpoint,
          ._200Ok,
          ._201Created,
          ._202Accepted,
          ._203NonAuthoritativeInformation,
          ._204NoContent,
          ._205ResetContent,
          ._206PartialContent,
          ._207MultiStatus,
          ._208AlreadyReported,
          ._226ImUsed,
          ._300MultipleChoices,
          ._301MovedPermanently,
          ._302Found,
          ._302MovedTemporarily,
          ._303SeeOther,
          ._304NotModified,
          ._305UseProxy,
          ._307TemporaryRedirect,
          ._308PermanentRedirect,
          ._400BadRequest,
          ._401Unauthorized,
          ._402PaymentRequired,
          ._403Forbidden,
          ._404NotFound,
          ._405MethodNotAllowed,
          ._406NotAcceptable,
          ._407ProxyAuthenticationRequired,
          ._408RequestTimeout,
          ._409Conflict,
          ._410Gone,
          ._411LengthRequired,
          ._412PreconditionFailed,
          ._413PayloadTooLarge,
          ._413RequestEntityTooLarge,
          ._414UriTooLong,
          ._414RequestUriTooLong,
          ._415UnsupportedMediaType,
          ._416RequestedRangeNotSatisfiable,
          ._417ExpectationFailed,
          ._418IAmaTeapot,
          ._419InsufficientSpaceOnResource,
          ._420MethodFailure,
          ._421DestinationLocked,
          ._422UnprocessableEntity,
          ._423Locked,
          ._424FailedDependency,
          ._426UpgradeRequired,
          ._428PreconditionRequired,
          ._429TooManyRequests,
          ._431RequestHeaderFieldsTooLarge,
          ._451UnavailableForLegalReasons,
          ._500InternalServerError,
          ._501NotImplemented,
          ._502BadGateway,
          ._503ServiceUnavailable,
          ._504GatewayTimeout,
          ._505HttpVersionNotSupported,
          ._506VariantAlsoNegotiates,
          ._507InsufficientStorage,
          ._508LoopDetected,
          ._509BandwidthLimitExceeded,
          ._510NotExtended,
          ._511NetworkAuthenticationRequired,
        ]
    }

    public var apiErrorType: ApiErrorType?

    public var authorizerResponseCode: String?

    public var authorizerResponseMessage: String?

    public var error: String?

    public var message: String?

    public var path: String?

    public var status: Status?

    public var timeStamp: DateTime?

    public init(apiErrorType: ApiErrorType? = nil, authorizerResponseCode: String? = nil, authorizerResponseMessage: String? = nil, error: String? = nil, message: String? = nil, path: String? = nil, status: Status? = nil, timeStamp: DateTime? = nil) {
        self.apiErrorType = apiErrorType
        self.authorizerResponseCode = authorizerResponseCode
        self.authorizerResponseMessage = authorizerResponseMessage
        self.error = error
        self.message = message
        self.path = path
        self.status = status
        self.timeStamp = timeStamp
    }

    private enum CodingKeys: String, CodingKey {
        case apiErrorType
        case authorizerResponseCode
        case authorizerResponseMessage
        case error
        case message
        case path
        case status
        case timeStamp
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        apiErrorType = try container.decodeIfPresent(.apiErrorType)
        authorizerResponseCode = try container.decodeIfPresent(.authorizerResponseCode)
        authorizerResponseMessage = try container.decodeIfPresent(.authorizerResponseMessage)
        error = try container.decodeIfPresent(.error)
        message = try container.decodeIfPresent(.message)
        path = try container.decodeIfPresent(.path)
        status = try container.decodeIfPresent(.status)
        timeStamp = try container.decodeIfPresent(.timeStamp)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(apiErrorType, forKey: .apiErrorType)
        try container.encodeIfPresent(authorizerResponseCode, forKey: .authorizerResponseCode)
        try container.encodeIfPresent(authorizerResponseMessage, forKey: .authorizerResponseMessage)
        try container.encodeIfPresent(error, forKey: .error)
        try container.encodeIfPresent(message, forKey: .message)
        try container.encodeIfPresent(path, forKey: .path)
        try container.encodeIfPresent(status, forKey: .status)
        try container.encodeIfPresent(timeStamp, forKey: .timeStamp)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? ApiError else { return false }
      guard self.apiErrorType == object.apiErrorType else { return false }
      guard self.authorizerResponseCode == object.authorizerResponseCode else { return false }
      guard self.authorizerResponseMessage == object.authorizerResponseMessage else { return false }
      guard self.error == object.error else { return false }
      guard self.message == object.message else { return false }
      guard self.path == object.path else { return false }
      guard self.status == object.status else { return false }
      guard self.timeStamp == object.timeStamp else { return false }
      return true
    }

    public static func == (lhs: ApiError, rhs: ApiError) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
