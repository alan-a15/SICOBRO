//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class URL: APIModel {

    public var authority: String?

    public var content: [String: Any]?

    public var defaultPort: Int?

    public var file: String?

    public var host: String?

    public var path: String?

    public var port: Int?

    public var `protocol`: String?

    public var query: String?

    public var ref: String?

    public var userInfo: String?

    public init(authority: String? = nil, content: [String: Any]? = nil, defaultPort: Int? = nil, file: String? = nil, host: String? = nil, path: String? = nil, port: Int? = nil, `protocol`: String? = nil, query: String? = nil, ref: String? = nil, userInfo: String? = nil) {
        self.authority = authority
        self.content = content
        self.defaultPort = defaultPort
        self.file = file
        self.host = host
        self.path = path
        self.port = port
        self.`protocol` = `protocol`
        self.query = query
        self.ref = ref
        self.userInfo = userInfo
    }

    private enum CodingKeys: String, CodingKey {
        case authority
        case content
        case defaultPort
        case file
        case host
        case path
        case port
        case `protocol` = "protocol"
        case query
        case ref
        case userInfo
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        authority = try container.decodeIfPresent(.authority)
        content = try container.decodeAnyIfPresent(.content)
        defaultPort = try container.decodeIfPresent(.defaultPort)
        file = try container.decodeIfPresent(.file)
        host = try container.decodeIfPresent(.host)
        path = try container.decodeIfPresent(.path)
        port = try container.decodeIfPresent(.port)
        `protocol` = try container.decodeIfPresent(.`protocol`)
        query = try container.decodeIfPresent(.query)
        ref = try container.decodeIfPresent(.ref)
        userInfo = try container.decodeIfPresent(.userInfo)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(authority, forKey: .authority)
        try container.encodeAnyIfPresent(content, forKey: .content)
        try container.encodeIfPresent(defaultPort, forKey: .defaultPort)
        try container.encodeIfPresent(file, forKey: .file)
        try container.encodeIfPresent(host, forKey: .host)
        try container.encodeIfPresent(path, forKey: .path)
        try container.encodeIfPresent(port, forKey: .port)
        try container.encodeIfPresent(`protocol`, forKey: .`protocol`)
        try container.encodeIfPresent(query, forKey: .query)
        try container.encodeIfPresent(ref, forKey: .ref)
        try container.encodeIfPresent(userInfo, forKey: .userInfo)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? URL else { return false }
      guard self.authority == object.authority else { return false }
      guard NSDictionary(dictionary: self.content ?? [:]).isEqual(to: object.content ?? [:]) else { return false }
      guard self.defaultPort == object.defaultPort else { return false }
      guard self.file == object.file else { return false }
      guard self.host == object.host else { return false }
      guard self.path == object.path else { return false }
      guard self.port == object.port else { return false }
      guard self.`protocol` == object.`protocol` else { return false }
      guard self.query == object.query else { return false }
      guard self.ref == object.ref else { return false }
      guard self.userInfo == object.userInfo else { return false }
      return true
    }

    public static func == (lhs: URL, rhs: URL) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
