//
// Generated by SwagGen
// https://github.com/yonaskolb/SwagGen
//

import Foundation

public class File: APIModel {

    public var absolute: Bool?

    public var absoluteFile: File?

    public var absolutePath: String?

    public var canonicalFile: File?

    public var canonicalPath: String?

    public var directory: Bool?

    public var file: Bool?

    public var freeSpace: Int?

    public var hidden: Bool?

    public var name: String?

    public var parent: String?

    public var parentFile: File?

    public var path: String?

    public var totalSpace: Int?

    public var usableSpace: Int?

    public init(absolute: Bool? = nil, absoluteFile: File? = nil, absolutePath: String? = nil, canonicalFile: File? = nil, canonicalPath: String? = nil, directory: Bool? = nil, file: Bool? = nil, freeSpace: Int? = nil, hidden: Bool? = nil, name: String? = nil, parent: String? = nil, parentFile: File? = nil, path: String? = nil, totalSpace: Int? = nil, usableSpace: Int? = nil) {
        self.absolute = absolute
        self.absoluteFile = absoluteFile
        self.absolutePath = absolutePath
        self.canonicalFile = canonicalFile
        self.canonicalPath = canonicalPath
        self.directory = directory
        self.file = file
        self.freeSpace = freeSpace
        self.hidden = hidden
        self.name = name
        self.parent = parent
        self.parentFile = parentFile
        self.path = path
        self.totalSpace = totalSpace
        self.usableSpace = usableSpace
    }

    private enum CodingKeys: String, CodingKey {
        case absolute
        case absoluteFile
        case absolutePath
        case canonicalFile
        case canonicalPath
        case directory
        case file
        case freeSpace
        case hidden
        case name
        case parent
        case parentFile
        case path
        case totalSpace
        case usableSpace
    }

    public required init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)

        absolute = try container.decodeIfPresent(.absolute)
        absoluteFile = try container.decodeIfPresent(.absoluteFile)
        absolutePath = try container.decodeIfPresent(.absolutePath)
        canonicalFile = try container.decodeIfPresent(.canonicalFile)
        canonicalPath = try container.decodeIfPresent(.canonicalPath)
        directory = try container.decodeIfPresent(.directory)
        file = try container.decodeIfPresent(.file)
        freeSpace = try container.decodeIfPresent(.freeSpace)
        hidden = try container.decodeIfPresent(.hidden)
        name = try container.decodeIfPresent(.name)
        parent = try container.decodeIfPresent(.parent)
        parentFile = try container.decodeIfPresent(.parentFile)
        path = try container.decodeIfPresent(.path)
        totalSpace = try container.decodeIfPresent(.totalSpace)
        usableSpace = try container.decodeIfPresent(.usableSpace)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)

        try container.encodeIfPresent(absolute, forKey: .absolute)
        try container.encodeIfPresent(absoluteFile, forKey: .absoluteFile)
        try container.encodeIfPresent(absolutePath, forKey: .absolutePath)
        try container.encodeIfPresent(canonicalFile, forKey: .canonicalFile)
        try container.encodeIfPresent(canonicalPath, forKey: .canonicalPath)
        try container.encodeIfPresent(directory, forKey: .directory)
        try container.encodeIfPresent(file, forKey: .file)
        try container.encodeIfPresent(freeSpace, forKey: .freeSpace)
        try container.encodeIfPresent(hidden, forKey: .hidden)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(parent, forKey: .parent)
        try container.encodeIfPresent(parentFile, forKey: .parentFile)
        try container.encodeIfPresent(path, forKey: .path)
        try container.encodeIfPresent(totalSpace, forKey: .totalSpace)
        try container.encodeIfPresent(usableSpace, forKey: .usableSpace)
    }

    public func isEqual(to object: Any?) -> Bool {
      guard let object = object as? File else { return false }
      guard self.absolute == object.absolute else { return false }
      guard self.absoluteFile == object.absoluteFile else { return false }
      guard self.absolutePath == object.absolutePath else { return false }
      guard self.canonicalFile == object.canonicalFile else { return false }
      guard self.canonicalPath == object.canonicalPath else { return false }
      guard self.directory == object.directory else { return false }
      guard self.file == object.file else { return false }
      guard self.freeSpace == object.freeSpace else { return false }
      guard self.hidden == object.hidden else { return false }
      guard self.name == object.name else { return false }
      guard self.parent == object.parent else { return false }
      guard self.parentFile == object.parentFile else { return false }
      guard self.path == object.path else { return false }
      guard self.totalSpace == object.totalSpace else { return false }
      guard self.usableSpace == object.usableSpace else { return false }
      return true
    }

    public static func == (lhs: File, rhs: File) -> Bool {
        return lhs.isEqual(to: rhs)
    }
}
